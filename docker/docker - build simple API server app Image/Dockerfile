#base image - node 사용하고 추가적으로 구성
FROM node

#npm install 같은 명령어를 /app 내에서 실행하고 싶기 때문에 작업 디렉토리를 설정한다.
#docker의 모든 후속 명령이 이제부터 /app에서 실행된다.
WORKDIR /app

#첫번째 경로 = 컨테이너의 외부 경로(이미지로 복사되어야 할 파일들이 있는 곳) , "." => Dockerfile과 같은 폴더에 있다.
#두번째 경로 = 그 이미지를 저장해야하는 내부 경로, 각 컨테이너의 자체 파일 시스템, "./" => docker 컨테이너의 현재 작업 디렉토리 
#COPY . ./ 과 같이 상대 경로로 표시하여도 된다.
#복사한 시점에서 소스 코드의 스냅샷을 만든다.
#따라서 소스코드의 변경 사항이 생겼다면, 이미지를 다시 "빌드"해야 한다.
#빌드 후에는 잠긴 상태로 완료되는 것.
#컨테이너를 다시 실행해 봤자 이미 이전 소스코드 기준의 이미지만을 실행할 뿐이다.


#도커는 모든 명령 결과를 캐쉬하여 이미지를 다시 빌드할 때
#특정 명령을 재실행할 필요 없으면, 케쉬된 결과를 사용한다.
# => 레이어 기반 아키텍쳐
#모든 명령은 Dockerfule의 레이어를 나타낸다.
#변경된 부분만 재평가

#이미지는 읽기 전용이다.
#명령이 실행되고, 이미지가 빌드되면 이미지가 잠기며 코드를 변경할 수 없다

#하나의 레이어가 변경될 때 다른 모든 후속 레이어가 다시 빌드된다.
#따라서 COPY 이후 npm install 실행하는 것 보다는 다음과 같이 변경하면 최적화가 가능하다.
COPY package.json /app 
RUN npm install
COPY . /app

#이렇게 하면 package.json 파일에 변경이 있을 때만 install을 재실시한다.



#항상 명령을 실행하기 이전에, 우리의 로컬 시스템에 특정 포트를 노출하고 싶다는 것을 docker에게 알려야 한다.
#이 명령은 documentation 목적으로만 추가됨 -> 실제로는 아무것도 하지 않는다.
#추가하는 것을 권장
#실제로 포트 노출은 다음 명령어를 통해서 실시
#docker run -p 3000(local port, app에 acess하는 입구):80(내부 컨테이너 노출 포트) image_아이디
EXPOSE 80

#서버를 시작
#RUN node server.js 하면 이미지가 빌드될 때마다 실행되기 때문에 틀리다.
#이미지를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행한다!!
#CMD를 사용하면, 이미지를기반으로 컨테이너가 시작될 때만 실행된다.
CMD ["node", "server.js"]
